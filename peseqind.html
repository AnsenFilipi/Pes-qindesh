<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pes√´qind - Albanian Card Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@400;600;800&family=Work+Sans:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #1a1a2e;
            --bg-medium: #16213e;
            --accent-gold: #e94560;
            --accent-light: #f38181;
            --text-light: #eee;
            --card-bg: #fff;
            --success: #06d6a0;
            --warning: #ffc93c;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Work Sans', sans-serif;
            background: linear-gradient(135deg, var(--bg-dark) 0%, var(--bg-medium) 100%);
            min-height: 100vh;
            color: var(--text-light);
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-family: 'Crimson Pro', serif;
            font-size: 4em;
            font-weight: 800;
            color: var(--accent-gold);
            text-shadow: 0 0 30px rgba(233, 69, 96, 0.5);
            margin-bottom: 5px;
            letter-spacing: 3px;
        }

        .tagline {
            font-size: 1.1em;
            color: var(--accent-light);
            font-weight: 300;
            letter-spacing: 2px;
        }

        .mode-select, .cut-screen, .turn-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-box {
            background: var(--bg-medium);
            border: 3px solid var(--accent-gold);
            border-radius: 20px;
            padding: 50px;
            text-align: center;
            max-width: 600px;
        }

        .modal-box h2 {
            font-family: 'Crimson Pro', serif;
            font-size: 2.5em;
            color: var(--accent-gold);
            margin-bottom: 20px;
        }

        .modal-box p {
            color: #ccc;
            margin-bottom: 30px;
            line-height: 1.6;
            font-size: 1.1em;
        }

        .mode-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .mode-btn {
            padding: 20px 40px;
            font-size: 1.2em;
            background: var(--accent-gold);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 700;
            transition: all 0.3s;
            font-family: 'Work Sans', sans-serif;
        }

        .mode-btn:hover {
            background: #d63850;
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(233, 69, 96, 0.5);
        }

        .mode-btn.secondary {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid var(--accent-gold);
        }

        .mode-btn.secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .cut-slider {
            width: 100%;
            margin: 30px 0;
        }

        .cut-slider input {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
        }

        .cut-value {
            font-size: 2em;
            color: var(--accent-gold);
            margin: 20px 0;
            font-weight: 700;
        }

        .revealed-card-display {
            margin: 20px auto;
        }

        .banned-card-zone {
            background: rgba(255, 0, 0, 0.1);
            border: 2px dashed #ff4444;
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            text-align: center;
        }

        .banned-card-label {
            color: #ff6666;
            font-size: 0.9em;
            margin-bottom: 10px;
            font-weight: 700;
            text-transform: uppercase;
        }

        .scores {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 25px;
        }

        .score-card {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid var(--accent-gold);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            backdrop-filter: blur(10px);
        }

        .score-title {
            font-size: 0.85em;
            color: var(--accent-light);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 10px;
        }

        .score-main {
            font-family: 'Crimson Pro', serif;
            font-size: 3em;
            font-weight: 800;
            color: var(--accent-gold);
            line-height: 1;
        }

        .score-sub {
            margin-top: 8px;
            font-size: 0.9em;
            color: #aaa;
        }

        .game-area {
            display: grid;
            grid-template-rows: auto auto auto auto;
            gap: 20px;
        }

        .zone {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .zone-title {
            font-size: 1em;
            font-weight: 700;
            color: var(--accent-gold);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .turn-indicator {
            background: var(--accent-gold);
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.75em;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .cards-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            min-height: 120px;
            align-items: flex-start;
        }

        .empty-text {
            color: #555;
            font-style: italic;
            padding: 40px;
            text-align: center;
            width: 100%;
        }

        .card {
            width: 65px;
            height: 90px;
            background: var(--card-bg);
            border-radius: 6px;
            border: 2px solid #333;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 6px;
            cursor: pointer;
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            position: relative;
            user-select: none;
        }

        .card:hover {
            transform: translateY(-10px) scale(1.05);
            box-shadow: 0 8px 20px rgba(233, 69, 96, 0.4);
        }

        .card.selected {
            transform: translateY(-15px) scale(1.08);
            border-color: var(--accent-gold);
            box-shadow: 0 0 25px rgba(233, 69, 96, 0.7);
        }

        .card.red {
            color: #c41e3a;
        }

        .card.black {
            color: #1a1a1a;
        }

        .card.wild {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            border-color: var(--accent-gold);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.2); }
        }

        .card-rank {
            font-size: 1.2em;
            font-weight: 700;
        }

        .card-suit {
            font-size: 1.8em;
            line-height: 1;
        }

        .card-rank-bottom {
            font-size: 1.2em;
            font-weight: 700;
            transform: rotate(180deg);
        }

        .combination {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            background: rgba(255, 255, 255, 0.08);
            padding: 8px;
            border-radius: 8px;
            border: 1px solid rgba(233, 69, 96, 0.3);
        }

        .combo-points {
            background: var(--accent-gold);
            color: white;
            padding: 4px 10px;
            border-radius: 5px;
            font-weight: 700;
            font-size: 0.85em;
            margin-left: 5px;
        }

        .river-card {
            position: relative;
        }

        .river-number {
            position: absolute;
            top: -8px;
            right: -8px;
            background: var(--accent-gold);
            color: white;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75em;
            font-weight: 700;
            border: 2px solid var(--bg-dark);
            z-index: 10;
        }

        .controls {
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 25px;
        }

        button {
            padding: 12px 24px;
            font-size: 0.95em;
            font-weight: 700;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Work Sans', sans-serif;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
        }

        .btn-primary {
            background: var(--accent-gold);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: #d63850;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(233, 69, 96, 0.4);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-light);
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.15);
        }

        .btn-success {
            background: var(--success);
            color: white;
        }

        .btn-success:hover:not(:disabled) {
            background: #05c496;
            transform: translateY(-2px);
        }

        button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .message {
            text-align: center;
            padding: 15px 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-weight: 600;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .msg-info {
            background: rgba(33, 150, 243, 0.2);
            border: 2px solid #2196f3;
            color: #64b5f6;
        }

        .msg-success {
            background: rgba(6, 214, 160, 0.2);
            border: 2px solid var(--success);
            color: var(--success);
        }

        .msg-warning {
            background: rgba(255, 201, 60, 0.2);
            border: 2px solid var(--warning);
            color: var(--warning);
        }

        .msg-error {
            background: rgba(233, 69, 96, 0.2);
            border: 2px solid var(--accent-gold);
            color: var(--accent-light);
        }

        .rules {
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid var(--accent-gold);
            border-radius: 12px;
            padding: 25px;
            margin-top: 30px;
        }

        .rules h3 {
            font-family: 'Crimson Pro', serif;
            font-size: 1.8em;
            color: var(--accent-gold);
            margin-bottom: 15px;
        }

        .rules ul {
            margin-left: 25px;
            line-height: 1.8;
        }

        .rules li {
            margin-bottom: 8px;
            color: #ccc;
        }

        .deck-display {
            text-align: center;
            margin-top: 15px;
            display: flex;
            gap: 20px;
            justify-content: center;
            align-items: flex-start;
        }

        .deck-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .deck-icon {
            width: 65px;
            height: 90px;
            background: linear-gradient(135deg, var(--bg-medium) 0%, var(--bg-dark) 100%);
            border: 2px solid var(--accent-gold);
            border-radius: 6px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5em;
            margin-bottom: 8px;
        }

        .deck-count {
            color: #aaa;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <!-- Mode Selection -->
    <div id="modeSelect" class="mode-select">
        <div class="modal-box">
            <h2>Select Game Mode</h2>
            <p>Choose how you want to play Peseqind</p>
            <div class="mode-buttons">
                <button class="mode-btn" onclick="game.selectMode('ai')">Play vs AI</button>
                <button class="mode-btn secondary" onclick="game.selectMode('local')">Local 2-Player<br><small>(Pass & Play)</small></button>
            </div>
            <div style="margin-top: 30px; padding-top: 30px; border-top: 2px solid rgba(255, 215, 0, 0.3);">
                <p style="font-size: 0.9em; margin-bottom: 15px;">Language / Gjuha</p>
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button class="mode-btn secondary" style="padding: 10px 20px; font-size: 0.9em;" onclick="game.setLanguage('en')">English üá∫üá∏</button>
                    <button class="mode-btn secondary" style="padding: 10px 20px; font-size: 0.9em;" onclick="game.setLanguage('sq')">Shqip üá¶üá±</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Cutting Screen -->
    <div id="cutScreen" class="cut-screen" style="display:none;">
        <div class="modal-box">
            <h2 id="cutterName">Player 1</h2>
            <p>Cut the deck by selecting a position (1-52)</p>
            <div class="cut-slider">
                <input type="range" id="cutSlider" min="1" max="52" value="26" oninput="game.updateCutValue(this.value)">
            </div>
            <div class="cut-value">Card Position: <span id="cutPosition">26</span></div>
            <button class="mode-btn" onclick="game.revealCut()">Reveal Card</button>
        </div>
    </div>

    <!-- Cut Result Screen -->
    <div id="cutResultScreen" class="cut-screen" style="display:none;">
        <div class="modal-box">
            <h2>Cut Result</h2>
            <div id="cutCardDisplay" class="revealed-card-display"></div>
            <p id="cutMessage" style="font-size: 1.2em; margin: 20px 0;"></p>
            <button class="mode-btn" onclick="game.startAfterCut()">Start Game</button>
        </div>
    </div>

    <!-- Turn Transition Screen -->
    <div id="turnScreen" class="turn-screen" style="display:none;">
        <div class="modal-box">
            <h2 id="turnPlayerName"></h2>
            <p>Get ready for your turn!</p>
            <p id="turnPhaseInfo" style="color: var(--accent-light); font-size: 1em;"></p>
            <button class="mode-btn" onclick="game.continueTurn()">Continue</button>
        </div>
    </div>

    <!-- Main Game Container -->
    <div class="container" id="gameContainer" style="display:none;">
        <header>
            <h1>PESEQIND</h1>
            <p class="tagline">Albanian Card Game</p>
        </header>

        <div class="scores">
            <div class="score-card">
                <div class="score-title" id="player1ScoreTitle">Player 1 Score</div>
                <div class="score-main" id="playerTotal">0</div>
                <div class="score-sub">Round: <span id="playerRound">0</span> pts</div>
            </div>
            <div class="score-card">
                <div class="score-title" id="player2ScoreTitle">Player 2 Score</div>
                <div class="score-main" id="opponentTotal">0</div>
                <div class="score-sub">Round: <span id="opponentRound">0</span> pts</div>
            </div>
        </div>

        <div id="messageBox" style="display:none;"></div>

        <div class="game-area">
            <!-- Player 2 Combinations -->
            <div class="zone">
                <div class="zone-title">
                    <span id="player2ZoneTitle">PLAYER 2</span> COMBINATIONS
                    <span id="oppTurnIndicator" class="turn-indicator" style="display:none;">THEIR TURN</span>
                </div>
                <div id="opponentCombos" class="cards-container">
                    <div class="empty-text">No combinations yet</div>
                </div>
            </div>

            <!-- River -->
            <div class="zone">
                <div class="zone-title">RIVER (SACRIFICE PILE)</div>
                <div id="riverZone" class="cards-container">
                    <div class="empty-text">River is empty - both players sacrifice first</div>
                </div>
            </div>

            <!-- Player 1 Combinations -->
            <div class="zone">
                <div class="zone-title">
                    <span id="player1ZoneTitle">PLAYER 1</span> COMBINATIONS
                    <span id="playerTurnIndicator" class="turn-indicator" style="display:none;">YOUR TURN</span>
                </div>
                <div id="playerCombos" class="cards-container">
                    <div class="empty-text">No combinations yet</div>
                </div>
            </div>

            <!-- Current Player Hand -->
            <div class="zone">
                <div class="zone-title"><span id="currentHandTitle">YOUR</span> HAND</div>
                <div id="playerHand" class="cards-container"></div>
                <div class="deck-display">
                    <div class="deck-item">
                        <div class="deck-icon">üé¥</div>
                        <div class="deck-count">Deck: <span id="deckCount">0</span></div>
                    </div>
                    <div id="bannedCardContainer" style="display:none;" class="deck-item">
                        <div id="bannedCardDisplay"></div>
                        <div class="deck-count" style="color: #ff6666;">Banned Card</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="controls">
            <button class="btn-secondary" onclick="game.drawFromDeck()" id="drawBtn">Draw from Deck</button>
            <button class="btn-success" onclick="game.playCombination()" id="playBtn">Play Combination</button>
            <button class="btn-primary" onclick="game.sacrificeCard()" id="sacrificeBtn">Sacrifice Card</button>
            <button class="btn-secondary" onclick="game.clearSelection()">Clear Selection</button>
            <button class="btn-secondary" onclick="game.newGame()">New Game</button>
            <button class="btn-secondary" onclick="game.toggleRules()">Rules</button>
        </div>

        <div id="rulesSection" class="rules" style="display:none;">
            <h3>Peseqind Rules</h3>
            <ul>
                <li><strong>Goal:</strong> First to 500 total points</li>
                <li><strong>Cutting:</strong> One player cuts deck, if 2 is revealed they get it, otherwise it's banned</li>
                <li><strong>Setup:</strong> 8 cards each, cutter goes second</li>
                <li><strong>First Turn:</strong> Both sacrifice 1 card to river (NO DRAW)</li>
                <li><strong>Card Values:</strong> A=15pts, 2=wild(50pts with other 2s), 3-8=5pts, 9-K=10pts</li>
                <li><strong>Turn Phases:</strong>
                    <ol>
                        <li>Draw: Draw from deck OR pick from river (card + all after) - <strong>RIVER ONLY AVAILABLE AFTER FIRST 25+ PT COMBO!</strong></li>
                        <li>Play: (Optional) Play combinations or add single cards to existing ones</li>
                        <li>Sacrifice: Discard 1 card to river</li>
                    </ol>
                </li>
                <li><strong>First Play:</strong> Must be 25+ points to start placing combinations</li>
                <li><strong>Valid Combos (3+ cards):</strong>
                    <ul>
                        <li>Sets: Same rank (Q-Q-Q = 30pts)</li>
                        <li>Runs: Sequential same suit (8‚ô•-9‚ô•-10‚ô• = 20pts)</li>
                        <li>Wild 2: Substitutes any card, takes its value</li>
                    </ul>
                </li>
                <li><strong>Adding Cards:</strong> Select 1 card and click "Play Combination" to add to any combo (yours or opponent's) - you get the points! Max 4 of a kind.</li>
                <li><strong>Round End:</strong> Player empties hand, opponent subtracts remaining card values from their score (can go negative!)</li>
            </ul>
        </div>
    </div>

    <script>
        class Card {
            constructor(suit, rank) {
                this.suit = suit;
                this.rank = rank;
            }

            getValue() {
                if (this.rank === 'A') return 15;
                if (this.rank === '2') return 50;
                if (['3','4','5','6','7','8'].includes(this.rank)) return 5;
                if (['9','10','J','Q','K'].includes(this.rank)) return 10;
                return 0;
            }

            getRankValue() {
                const map = {'A':14,'K':13,'Q':12,'J':11,'10':10,'9':9,'8':8,'7':7,'6':6,'5':5,'4':4,'3':3,'2':2};
                return map[this.rank];
            }

            getSuit() {
                const symbols = {'hearts':'‚ô•','diamonds':'‚ô¶','clubs':'‚ô£','spades':'‚ô†'};
                return symbols[this.suit];
            }

            getColor() {
                return (this.suit === 'hearts' || this.suit === 'diamonds') ? 'red' : 'black';
            }

            toHTML() {
                const wild = this.rank === '2' ? 'wild' : '';
                return `
                    <div class="card ${this.getColor()} ${wild}">
                        <div class="card-rank">${this.rank}</div>
                        <div class="card-suit">${this.getSuit()}</div>
                        <div class="card-rank-bottom">${this.rank}</div>
                    </div>
                `;
            }
        }

        class Game {
            constructor() {
                this.gameMode = null;
                this.firstGameStarter = 0; // Alternates between rounds
                this.language = 'en'; // Default to English
                this.translations = {
                    en: {
                        title: 'PESEQIND',
                        tagline: 'Albanian Card Game',
                        selectMode: 'Select Game Mode',
                        selectModeDesc: 'Choose how you want to play Peseqind',
                        playVsAI: 'Play vs AI',
                        local2Player: 'Local 2-Player',
                        passPlay: '(Pass & Play)',
                        language: 'Language / Gjuha',
                        player1: 'Player 1',
                        player2: 'Player 2',
                        you: 'You',
                        yourHand: 'YOUR HAND',
                        yourCombos: 'YOUR COMBINATIONS',
                        opponentCombos: 'OPPONENT COMBINATIONS',
                        ai: 'AI',
                        river: 'RIVER (SACRIFICE PILE)',
                        riverEmpty: 'River is empty - both players sacrifice first',
                        noCombos: 'No combinations yet',
                        yourScore: 'Your Score',
                        opponentScore: 'Opponent Score',
                        aiScore: 'AI Score',
                        round: 'Round',
                        pts: 'pts',
                        deck: 'Deck',
                        bannedCard: 'Banned Card',
                        drawFromDeck: 'Draw from Deck',
                        playCombination: 'Play Combination',
                        sacrificeCard: 'Sacrifice Card',
                        clearSelection: 'Clear Selection',
                        newGame: 'New Game',
                        rules: 'Rules',
                        cutDeck: 'Cut the Deck',
                        cutDesc: 'Cut the deck by selecting a position (1-52)',
                        cardPosition: 'Card Position',
                        revealCard: 'Reveal Card',
                        cutResult: 'Cut Result',
                        startGame: 'Start Game',
                        getTurn: 'Get ready for your turn!',
                        continue: 'Continue',
                        firstTurnSacrifice: 'First turn: Sacrifice 1 card ONLY (no draw yet)',
                        sacrificePhase: 'Sacrifice a card to the river',
                        drawPhase: 'Draw from deck or pick from river',
                        playPhase: 'Play combinations (optional)',
                        theirTurn: 'THEIR TURN',
                        yourTurn: 'YOUR TURN',
                        
                        // Messages
                        msgCutIs2: "It's a 2! {player} gets this card in their starting hand.",
                        msgCutBanned: "This card is now banned - cannot be used in any combinations this round.",
                        msgNewRound: 'New round! {player} goes first. Both players start with 8 cards and must sacrifice 1 card each (NO DRAW on first turn).',
                        msgBothSacrificed: 'Both players sacrificed (now 7 cards each). {player}\'s turn to draw!',
                        msgSacrificed: '‚úì {player} sacrificed {card} to the river',
                        msgDrewCard: '‚úì {player} drew {card} from deck',
                        msgAIDrew: 'AI drew a card from the deck',
                        msgPickedRiver: '{player} picked {card} from river (+ {count} more). Must use it in a combination this turn!',
                        msgPlayed: '‚úì {player} played {type} for {points} points!',
                        msgRoundOver: 'Round over! {player} emptied their hand. {opponent} loses {points} points.',
                        msgYouWin: 'üéâ {player} WINS! Final: {score1} to {score2} üéâ',
                        msgOpponentWins: '{player} wins! Final: {score1} to {score2}',
                        msgNewRoundStarting: 'New round starting...',
                        msgAISacrificed: 'AI sacrificed a card to the river',
                        msgYourTurnSacrifice: 'AI sacrificed. Your turn to sacrifice!',
                        msgYourTurnDraw: 'Both players sacrificed. Your turn to draw!',
                        msgYourTurn: 'AI sacrificed. Your turn!',
                        
                        // Errors
                        errWrongPhase: '‚ùå You can only pick from river during the DRAW phase! Current phase: {phase}',
                        errNoFirstCombo: '‚ùå You must play your first combination (25+ points) before you can pick from the river!',
                        errDrawPhase: '‚ùå You can only draw during the DRAW phase! Current phase: {phase}',
                        errDeckEmpty: '‚ùå Deck is empty! You must pick from the river.',
                        errSacrificePhase: '‚ùå You must SACRIFICE a card first before playing combinations!',
                        err3Cards: '‚ùå You need at least 3 cards to make a combination!',
                        errBannedCard: '‚ùå You cannot use the banned card in combinations!',
                        errFirstPlay25: '‚ùå Your FIRST combination must be worth at least 25 points! This combo is only worth {points} points.',
                        errSelectOne: '‚ùå Select exactly 1 card to sacrifice! You have {count} selected.',
                        errWrongPhaseGeneral: '‚ùå Wrong phase! You are in: {phase}'
                    },
                    sq: {
                        title: 'PESEQIND',
                        tagline: 'Loj√´ Tradicionale Shqiptare me Letra',
                        selectMode: 'Zgjidh M√´nyr√´n e Loj√´s',
                        selectModeDesc: 'Zgjidhni si d√´shironi t√´ luani Peseqind',
                        playVsAI: 'Luaj kund√´r AI',
                        local2Player: '2 Lojtar√´ Lokal√´',
                        passPlay: '(Kalo & Luaj)',
                        language: 'Language / Gjuha',
                        player1: 'Lojtari 1',
                        player2: 'Lojtari 2',
                        you: 'Ti',
                        yourHand: 'LETRAT E TUA',
                        yourCombos: 'KOMBINACIONET E TUA',
                        opponentCombos: 'KOMBINACIONET E KUND√ãRSHTARIT',
                        ai: 'AI',
                        river: 'LUMI (GRUMBULL SAKRIFICE)',
                        riverEmpty: 'Lumi √´sht√´ bosh - t√´ dy lojtar√´t sakrfikojn√´ s√´ pari',
                        noCombos: 'Ende pa kombinacione',
                        yourScore: 'Rezultati Yt',
                        opponentScore: 'Rezultati i Kund√´rshtarit',
                        aiScore: 'Rezultati i AI',
                        round: 'Raund',
                        pts: 'pik√´',
                        deck: 'Shufra',
                        bannedCard: 'Let√´r e Ndaluar',
                        drawFromDeck: 'Merr nga Shufra',
                        playCombination: 'Luaj Kombinacion',
                        sacrificeCard: 'Sakrifiko Let√´r',
                        clearSelection: 'Pastro Zgjedhjen',
                        newGame: 'Loj√´ e Re',
                        rules: 'Rregullat',
                        cutDeck: 'Prit Shufrat',
                        cutDesc: 'Prit shufrat duke zgjedhur nj√´ pozicion (1-52)',
                        cardPosition: 'Pozicioni i Letres',
                        revealCard: 'Shfaq Letr√´n',
                        cutResult: 'Rezultati i Prerjes',
                        startGame: 'Fillo Loj√´n',
                        getTurn: 'P√´rgatitu p√´r radh√´n t√´nde!',
                        continue: 'Vazhdo',
                        firstTurnSacrifice: 'Radha e par√´: Sakrifiko 1 let√´r VET√ãM (pa t√´rhequr ende)',
                        sacrificePhase: 'Sakrifiko nj√´ let√´r n√´ lum',
                        drawPhase: 'Merr nga shufra ose merr nga lumi',
                        playPhase: 'Luaj kombinacione (opsionale)',
                        theirTurn: 'RADHA E TYRE',
                        yourTurn: 'RADHA JOTE',
                        
                        // Messages
                        msgCutIs2: "√ãsht√´ nj√´ 2! {player} e merr k√´t√´ let√´r n√´ dor√´n fillestare.",
                        msgCutBanned: "Kjo let√´r tani √´sht√´ e ndaluar - nuk mund t√´ p√´rdoret n√´ asnj√´ kombinacion k√´t√´ raund.",
                        msgNewRound: 'Raund i ri! {player} fillon i pari. T√´ dy lojtar√´t fillojn√´ me 8 letra dhe duhet t√´ sakrfikojn√´ 1 let√´r secili (PA T√ãRHEQUR n√´ radh√´n e par√´).',
                        msgBothSacrificed: 'T√´ dy lojtar√´t sakrifikuan (tani 7 letra secili). Radha e {player} p√´r t√´ t√´rhequr!',
                        msgSacrificed: '‚úì {player} sakrifikoi {card} n√´ lum',
                        msgDrewCard: '‚úì {player} t√´rhoqi {card} nga shufra',
                        msgAIDrew: 'AI t√´rhoqi nj√´ let√´r nga shufra',
                        msgPickedRiver: '{player} mori {card} nga lumi (+ {count} m√´ shum√´). Duhet ta p√´rdor√´ n√´ nj√´ kombinacion k√´t√´ radh√´!',
                        msgPlayed: '‚úì {player} luajti {type} p√´r {points} pik√´!',
                        msgRoundOver: 'Raundi mbaroi! {player} zbrazi dor√´n. {opponent} humb {points} pik√´.',
                        msgYouWin: 'üéâ {player} FITOI! P√´rfundimtare: {score1} ndaj {score2} üéâ',
                        msgOpponentWins: '{player} fitoi! P√´rfundimtare: {score1} ndaj {score2}',
                        msgNewRoundStarting: 'Raund i ri po fillon...',
                        msgAISacrificed: 'AI sakrifikoi nj√´ let√´r n√´ lum',
                        msgYourTurnSacrifice: 'AI sakrifikoi. Radha jote p√´r t√´ sakrifikuar!',
                        msgYourTurnDraw: 'T√´ dy lojtar√´t sakrifikuan. Radha jote p√´r t√´ t√´rhequr!',
                        msgYourTurn: 'AI sakrifikoi. Radha jote!',
                        
                        // Errors
                        errWrongPhase: '‚ùå Mund t√´ merr√´sh nga lumi vet√´m gjat√´ faz√´s s√´ T√ãRHEQJES! Faza aktuale: {phase}',
                        errNoFirstCombo: '‚ùå Duhet t√´ luash kombinacionin e par√´ (25+ pik√´) p√´rpara se t√´ mund t√´ merr√´sh nga lumi!',
                        errDrawPhase: '‚ùå Mund t√´ t√´rhiqesh vet√´m gjat√´ faz√´s s√´ T√ãRHEQJES! Faza aktuale: {phase}',
                        errDeckEmpty: '‚ùå Shufra √´sht√´ bosh! Duhet t√´ merr√´sh nga lumi.',
                        errSacrificePhase: '‚ùå Duhet t√´ SAKRFIKOSH nj√´ let√´r s√´ pari p√´rpara se t√´ luash kombinacione!',
                        err3Cards: '‚ùå Ke nevoj√´ p√´r t√´ pakt√´n 3 letra p√´r t√´ b√´r√´ nj√´ kombinacion!',
                        errBannedCard: '‚ùå Nuk mund ta p√´rdor√´sh letr√´n e ndaluar n√´ kombinacione!',
                        errFirstPlay25: '‚ùå Kombinacioni i par√´ duhet t√´ jet√´ t√´ pakt√´n 25 pik√´! Ky kombinacion √´sht√´ vet√´m {points} pik√´.',
                        errSelectOne: '‚ùå Zgjidh sakt√´sisht 1 let√´r p√´r t√´ sakrfikuar! Ke {count} t√´ zgjedhura.',
                        errWrongPhaseGeneral: '‚ùå Faz√´ e gabuar! Je n√´: {phase}'
                    }
                };
                this.reset();
            }

            setLanguage(lang) {
                this.language = lang;
                this.updateUIText();
            }

            t(key, replacements = {}) {
                let text = this.translations[this.language][key] || this.translations['en'][key] || key;
                
                // Replace placeholders like {player}, {points}, etc.
                for (let [key, value] of Object.entries(replacements)) {
                    text = text.replace(`{${key}}`, value);
                }
                
                return text;
            }

            updateUIText() {
                // Update all static UI text based on current language
                const titleEl = document.querySelector('h1');
                if (titleEl) titleEl.textContent = this.t('title');
                
                const taglineEl = document.querySelector('.tagline');
                if (taglineEl) taglineEl.textContent = this.t('tagline');
                
                // Update mode select screen
                const modeSelectBox = document.querySelector('#modeSelect .modal-box');
                if (modeSelectBox && document.getElementById('modeSelect').style.display !== 'none') {
                    const h2 = modeSelectBox.querySelector('h2');
                    const p = modeSelectBox.querySelector('p');
                    const buttons = modeSelectBox.querySelectorAll('.mode-btn');
                    
                    if (h2) h2.textContent = this.t('selectMode');
                    if (p) p.textContent = this.t('selectModeDesc');
                    if (buttons[0]) buttons[0].innerHTML = this.t('playVsAI');
                    if (buttons[1]) buttons[1].innerHTML = this.t('local2Player') + '<br><small>' + this.t('passPlay') + '</small>';
                }
                
                // Update game controls if game is active
                const drawBtn = document.getElementById('drawBtn');
                if (drawBtn) drawBtn.textContent = this.t('drawFromDeck');
                
                const playBtn = document.getElementById('playBtn');
                if (playBtn) playBtn.textContent = this.t('playCombination');
                
                const sacrificeBtn = document.getElementById('sacrificeBtn');
                if (sacrificeBtn) sacrificeBtn.textContent = this.t('sacrificeCard');
                
                const buttons = document.querySelectorAll('.controls .btn-secondary');
                if (buttons[1]) buttons[1].textContent = this.t('clearSelection');
                if (buttons[2]) buttons[2].textContent = this.t('newGame');
                if (buttons[3]) buttons[3].textContent = this.t('rules');
                
                // Update zone titles - with safety checks
                const riverZone = document.getElementById('riverZone');
                if (riverZone) {
                    const riverZoneParent = riverZone.closest('.zone');
                    if (riverZoneParent) {
                        const riverTitle = riverZoneParent.querySelector('.zone-title');
                        if (riverTitle && riverTitle.childNodes[0]) {
                            riverTitle.childNodes[0].textContent = this.t('river');
                        }
                    }
                }
            }

            selectMode(mode) {
                this.gameMode = mode;
                document.getElementById('modeSelect').style.display = 'none';
                
                // Show cutting screen - labels will be updated when game actually starts
                this.showCuttingScreen();
            }

            updateGameLabels() {
                // Update labels based on mode and language - called when game container is visible
                if (this.gameMode === 'local') {
                    const p1Title = document.getElementById('player1ScoreTitle');
                    const p2Title = document.getElementById('player2ScoreTitle');
                    const p1Zone = document.getElementById('player1ZoneTitle');
                    const p2Zone = document.getElementById('player2ZoneTitle');
                    
                    if (p1Title) p1Title.textContent = this.t('player1') + ' Score';
                    if (p2Title) p2Title.textContent = this.t('player2') + ' Score';
                    if (p1Zone) p1Zone.textContent = this.t('player1').toUpperCase();
                    if (p2Zone) p2Zone.textContent = this.t('player2').toUpperCase();
                } else {
                    const p1Title = document.getElementById('player1ScoreTitle');
                    const p2Title = document.getElementById('player2ScoreTitle');
                    const p1Zone = document.getElementById('player1ZoneTitle');
                    const p2Zone = document.getElementById('player2ZoneTitle');
                    
                    if (p1Title) p1Title.textContent = this.t('yourScore');
                    if (p2Title) p2Title.textContent = this.t('aiScore');
                    if (p1Zone) p1Zone.textContent = this.t('you').toUpperCase();
                    if (p2Zone) p2Zone.textContent = this.t('ai').toUpperCase();
                }
                
                // Update button texts
                const drawBtn = document.getElementById('drawBtn');
                const playBtn = document.getElementById('playBtn');
                const sacrificeBtn = document.getElementById('sacrificeBtn');
                
                if (drawBtn) drawBtn.textContent = this.t('drawFromDeck');
                if (playBtn) playBtn.textContent = this.t('playCombination');
                if (sacrificeBtn) sacrificeBtn.textContent = this.t('sacrificeCard');
                
                const secButtons = document.querySelectorAll('.controls .btn-secondary');
                if (secButtons[1]) secButtons[1].textContent = this.t('clearSelection');
                if (secButtons[2]) secButtons[2].textContent = this.t('newGame');
                if (secButtons[3]) secButtons[3].textContent = this.t('rules');
            }

            showCuttingScreen() {
                const cutter = this.firstGameStarter;
                let cutterName;
                
                if (this.gameMode === 'local') {
                    cutterName = cutter === 0 ? this.t('player1') : this.t('player2');
                } else {
                    cutterName = cutter === 0 ? this.t('you') : this.t('ai');
                }
                
                if (this.gameMode === 'ai' && cutter === 1) {
                    // AI cuts automatically
                    const cutPos = Math.floor(Math.random() * 52) + 1;
                    this.performCut(cutPos);
                } else {
                    const cutterNameEl = document.getElementById('cutterName');
                    if (cutterNameEl) cutterNameEl.textContent = cutterName + ' - ' + this.t('cutDeck');
                    
                    const cutDescEl = document.querySelector('#cutScreen p');
                    if (cutDescEl) cutDescEl.textContent = this.t('cutDesc');
                    
                    const cutValueEl = document.querySelector('#cutScreen .cut-value');
                    if (cutValueEl) cutValueEl.innerHTML = this.t('cardPosition') + ': <span id="cutPosition">26</span>';
                    
                    const cutBtnEl = document.querySelector('#cutScreen .mode-btn');
                    if (cutBtnEl) cutBtnEl.textContent = this.t('revealCard');
                    
                    document.getElementById('cutScreen').style.display = 'flex';
                }
            }

            updateCutValue(value) {
                document.getElementById('cutPosition').textContent = value;
            }

            revealCut() {
                const cutPos = parseInt(document.getElementById('cutSlider').value);
                this.performCut(cutPos);
            }

            performCut(position) {
                // Create and shuffle deck first so cut position is random
                const tempDeck = this.createFullDeck();
                this.shuffleArray(tempDeck);
                
                // Get card at cut position
                const cutCard = tempDeck[position - 1];
                
                this.cutCard = cutCard;
                this.cutPosition = position;
                
                // Show result
                document.getElementById('cutScreen').style.display = 'none';
                document.getElementById('cutResultScreen').style.display = 'flex';
                
                const displayDiv = document.getElementById('cutCardDisplay');
                displayDiv.innerHTML = cutCard.toHTML();
                const cardEl = displayDiv.querySelector('.card');
                if (cardEl) {
                    cardEl.style.width = '100px';
                    cardEl.style.height = '140px';
                    cardEl.style.margin = '0 auto';
                }
                
                const resultH2 = document.querySelector('#cutResultScreen h2');
                if (resultH2) resultH2.textContent = this.t('cutResult');
                
                const resultBtn = document.querySelector('#cutResultScreen .mode-btn');
                if (resultBtn) resultBtn.textContent = this.t('startGame');
                
                const messageDiv = document.getElementById('cutMessage');
                const cutter = this.firstGameStarter;
                
                let cutterName;
                if (this.gameMode === 'local') {
                    cutterName = cutter === 0 ? this.t('player1') : this.t('player2');
                } else {
                    cutterName = cutter === 0 ? this.t('you') : this.t('ai');
                }
                
                if (messageDiv) {
                    if (cutCard.rank === '2') {
                        messageDiv.textContent = this.t('msgCutIs2', {player: cutterName});
                        this.cutterGets2 = true;
                    } else {
                        messageDiv.textContent = this.t('msgCutBanned');
                        this.cutterGets2 = false;
                        this.bannedCard = cutCard;
                    }
                }
            }

            startAfterCut() {
                document.getElementById('cutResultScreen').style.display = 'none';
                this.newRound();
            }

            reset() {
                this.playerHand = [];
                this.opponentHand = [];
                this.deck = [];
                this.river = [];
                this.playerCombos = [];
                this.opponentCombos = [];
                this.playerTotal = 0;
                this.opponentTotal = 0;
                this.playerRound = 0;
                this.opponentRound = 0;
                this.selected = [];
                this.turn = 0;
                this.phase = 'sacrifice';
                this.firstTurn = true;
                this.firstSacrificesDone = [];
                this.playerFirstPlay = false;
                this.opponentFirstPlay = false;
                this.bannedCard = null;
                this.cutCard = null;
                this.cutterGets2 = false;
            }

            newGame() {
                this.playerTotal = 0;
                this.opponentTotal = 0;
                this.firstGameStarter = 0;
                document.getElementById('gameContainer').style.display = 'none';
                this.showCuttingScreen();
            }

            newRound() {
                // Deal cards
                const deck = this.createFullDeck();
                
                // Remove cut card from deck
                const cutIndex = deck.findIndex(c => 
                    c.suit === this.cutCard.suit && c.rank === this.cutCard.rank
                );
                if (cutIndex > -1) {
                    deck.splice(cutIndex, 1);
                }
                
                // Shuffle
                this.shuffleArray(deck);
                
                // If cutter got the 2, they get 7 cards from deck + the 2 (total 8)
                // Otherwise, both get 8 cards from deck
                if (this.cutterGets2 && this.cutCard.rank === '2') {
                    const cutter = this.firstGameStarter;
                    if (cutter === 0) {
                        // Player 1 is cutter
                        this.playerHand = deck.slice(0, 7);
                        this.playerHand.push(this.cutCard); // Add the 2 to make 8 total
                        this.opponentHand = deck.slice(7, 15);
                        this.deck = deck.slice(15);
                    } else {
                        // Player 2 is cutter
                        this.playerHand = deck.slice(0, 8);
                        this.opponentHand = deck.slice(8, 15);
                        this.opponentHand.push(this.cutCard); // Add the 2 to make 8 total
                        this.deck = deck.slice(15);
                    }
                } else {
                    // Normal deal: 8 cards each
                    this.playerHand = deck.slice(0, 8);
                    this.opponentHand = deck.slice(8, 16);
                    this.deck = deck.slice(16);
                }
                
                this.river = [];
                this.playerCombos = [];
                this.opponentCombos = [];
                this.playerRound = 0;
                this.opponentRound = 0;
                this.selected = [];
                this.firstTurn = true;
                this.firstSacrificesDone = [];
                this.playerFirstPlay = false;
                this.opponentFirstPlay = false;
                
                // Non-cutter goes first
                this.turn = this.firstGameStarter === 0 ? 1 : 0;
                this.phase = 'sacrifice';
                
                // Show banned card if applicable
                if (this.bannedCard && this.cutCard.rank !== '2') {
                    document.getElementById('bannedCardContainer').style.display = 'block';
                    const bannedDiv = document.getElementById('bannedCardDisplay');
                    bannedDiv.innerHTML = this.bannedCard.toHTML();
                } else {
                    document.getElementById('bannedCardContainer').style.display = 'none';
                }
                
                document.getElementById('gameContainer').style.display = 'block';
                
                // Update all game labels with translations now that container is visible
                this.updateGameLabels();
                
                this.render();
                
                const starterName = this.gameMode === 'local' 
                    ? (this.turn === 0 ? this.t('player1') : this.t('player2'))
                    : (this.turn === 0 ? this.t('you') : this.t('ai'));
                
                this.showMessage(`New round! ${starterName} goes first. Both players start with 8 cards and must sacrifice 1 card each (NO DRAW on first turn).`, 'info');
                
                if (this.gameMode === 'local') {
                    this.showTurnScreen();
                } else if (this.turn === 1) {
                    // AI goes first
                    setTimeout(() => this.aiSacrifice(), 1500);
                }
            }

            createFullDeck() {
                const suits = ['hearts', 'diamonds', 'clubs', 'spades'];
                const ranks = ['2','3','4','5','6','7','8','9','10','J','Q','K','A'];
                const cards = [];
                
                for (let suit of suits) {
                    for (let rank of ranks) {
                        cards.push(new Card(suit, rank));
                    }
                }
                
                return cards;
            }

            shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            showTurnScreen() {
                const playerName = this.gameMode === 'local' 
                    ? `Player ${this.turn + 1}'s Turn` 
                    : (this.turn === 0 ? "Your Turn" : "AI Turn");
                
                document.getElementById('turnPlayerName').textContent = playerName;
                
                let phaseText;
                if (this.firstTurn) {
                    phaseText = 'First turn: Sacrifice 1 card ONLY (no draw yet)';
                } else {
                    phaseText = this.phase === 'sacrifice' 
                        ? 'Sacrifice a card to the river' 
                        : this.phase === 'draw'
                        ? 'Draw from deck or pick from river'
                        : 'Play combinations (optional)';
                }
                
                document.getElementById('turnPhaseInfo').textContent = phaseText;
                document.getElementById('turnScreen').style.display = 'flex';
                document.getElementById('gameContainer').style.display = 'none';
            }

            continueTurn() {
                document.getElementById('turnScreen').style.display = 'none';
                document.getElementById('gameContainer').style.display = 'block';
                this.render();
            }

            selectCard(idx) {
                const pos = this.selected.indexOf(idx);
                if (pos > -1) {
                    this.selected.splice(pos, 1);
                } else {
                    this.selected.push(idx);
                }
                this.render();
            }

            selectRiver(idx) {
                if (this.phase !== 'draw') {
                    this.showMessage('‚ùå You can only pick from river during the DRAW phase! Current phase: ' + this.phase.toUpperCase(), 'error');
                    return;
                }
                
                // Check if player has made their first combination
                const hasPlayed = this.turn === 0 ? this.playerFirstPlay : this.opponentFirstPlay;
                if (!hasPlayed) {
                    this.showMessage('‚ùå You must play your first combination (25+ points) before you can pick from the river!', 'error');
                    return;
                }
                
                this.pickFromRiver(idx);
            }

            pickFromRiver(idx) {
                const picked = this.river.splice(idx);
                const currentHand = this.turn === 0 ? this.playerHand : this.opponentHand;
                currentHand.push(...picked);
                
                const playerName = this.gameMode === 'local' 
                    ? `Player ${this.turn + 1}` 
                    : (this.turn === 0 ? 'You' : 'AI');
                
                this.showMessage(`‚úì ${playerName} picked ${picked[0].rank}${picked[0].getSuit()} from river (+ ${picked.length - 1} more cards)`, 'success');
                this.phase = 'play';
                this.render();
            }

            drawFromDeck() {
                if (this.phase !== 'draw') {
                    this.showMessage('‚ùå You can only draw during the DRAW phase! Current phase: ' + this.phase.toUpperCase(), 'error');
                    return;
                }
                if (this.deck.length === 0) {
                    this.showMessage('‚ùå Deck is empty! You must pick from the river.', 'error');
                    return;
                }
                
                const card = this.deck.pop();
                const currentHand = this.turn === 0 ? this.playerHand : this.opponentHand;
                currentHand.push(card);
                
                const playerName = this.gameMode === 'local' 
                    ? `Player ${this.turn + 1}` 
                    : (this.turn === 0 ? 'You' : 'AI');
                
                // Only show the card if it's the player or local mode
                if (this.turn === 0 || this.gameMode === 'local') {
                    this.showMessage(`‚úì ${playerName} drew ${card.rank}${card.getSuit()} from deck`, 'success');
                } else {
                    this.showMessage(`AI drew a card from the deck`, 'info');
                }
                
                this.phase = 'play';
                this.render();
            }

            playCombination() {
                if (this.phase === 'sacrifice') {
                    this.showMessage('‚ùå You must SACRIFICE a card first before playing combinations!', 'error');
                    return;
                }
                
                if (this.selected.length === 0) {
                    this.showMessage('‚ùå Select at least 1 card to play!', 'warning');
                    return;
                }

                const currentHand = this.turn === 0 ? this.playerHand : this.opponentHand;
                const hasPlayed = this.turn === 0 ? this.playerFirstPlay : this.opponentFirstPlay;

                // Check if adding single card to existing combination
                if (this.selected.length === 1) {
                    const card = currentHand[this.selected[0]];
                    
                    // Check banned card
                    if (this.bannedCard && card.rank === this.bannedCard.rank && card.suit === this.bannedCard.suit) {
                        this.showMessage('‚ùå You cannot use the banned card in combinations!', 'error');
                        return;
                    }
                    
                    // Try to add to own combinations first, then opponent's
                    const allCombos = [
                        ...this.playerCombos.map((c, i) => ({combo: c, owner: 0, index: i})),
                        ...this.opponentCombos.map((c, i) => ({combo: c, owner: 1, index: i}))
                    ];
                    
                    let added = false;
                    for (let comboData of allCombos) {
                        const result = this.canAddToCombo(card, comboData.combo);
                        if (result.canAdd) {
                            // Remove card from hand
                            currentHand.splice(this.selected[0], 1);
                            
                            // Add to combination
                            comboData.combo.cards.push(card);
                            comboData.combo.points += result.points;
                            
                            // Award points to current player
                            if (this.turn === 0) {
                                this.playerRound += result.points;
                            } else {
                                this.opponentRound += result.points;
                            }
                            
                            const playerName = this.gameMode === 'local' 
                                ? `Player ${this.turn + 1}` 
                                : (this.turn === 0 ? 'You' : 'AI');
                            
                            const ownerName = this.gameMode === 'local'
                                ? `Player ${comboData.owner + 1}'s`
                                : (comboData.owner === 0 ? 'your' : "opponent's");
                            
                            this.showMessage(`‚úì ${playerName} added ${card.rank}${card.getSuit()} to ${ownerName} combination for ${result.points} points!`, 'success');
                            
                            this.selected = [];
                            added = true;
                            
                            // Check if hand is empty
                            if (currentHand.length === 0) {
                                this.endRound();
                                return;
                            }
                            
                            this.render();
                            return;
                        }
                    }
                    
                    if (!added) {
                        this.showMessage('‚ùå Cannot add this card to any existing combination! You need at least 3 cards to make a new combination.', 'error');
                        return;
                    }
                }

                // Playing new combination (3+ cards)
                if (this.selected.length < 3) {
                    this.showMessage('‚ùå You need at least 3 cards to make a new combination!', 'warning');
                    return;
                }

                const cards = this.selected.map(i => currentHand[i]);
                
                // Check for banned card
                if (this.bannedCard) {
                    for (let card of cards) {
                        if (card.rank === this.bannedCard.rank && card.suit === this.bannedCard.suit) {
                            this.showMessage('‚ùå You cannot use the banned card in combinations!', 'error');
                            return;
                        }
                    }
                }
                
                const result = this.validateCombo(cards);

                if (!result.valid) {
                    this.showMessage('‚ùå ' + result.error, 'error');
                    return;
                }

                // First play check
                if (!hasPlayed && result.points < 25) {
                    this.showMessage(`‚ùå Your FIRST combination must be worth at least 25 points! This combo is only worth ${result.points} points.`, 'error');
                    return;
                }

                // Remove from hand
                this.selected.sort((a,b) => b - a).forEach(i => {
                    currentHand.splice(i, 1);
                });

                // Add to combos
                const currentCombos = this.turn === 0 ? this.playerCombos : this.opponentCombos;
                currentCombos.push({cards: cards, points: result.points, type: result.type});
                
                if (this.turn === 0) {
                    this.playerRound += result.points;
                    this.playerFirstPlay = true;
                } else {
                    this.opponentRound += result.points;
                    this.opponentFirstPlay = true;
                }

                const playerName = this.gameMode === 'local' 
                    ? `Player ${this.turn + 1}` 
                    : (this.turn === 0 ? 'You' : 'AI');
                
                this.showMessage(`‚úì ${playerName} played ${result.type} for ${result.points} points!`, 'success');
                this.selected = [];
                
                // Check empty hand
                if (currentHand.length === 0) {
                    this.endRound();
                    return;
                }

                this.render();
            }

            canAddToCombo(card, combo) {
                // Can't add more than 4 of a kind
                if (combo.cards.length >= 4) {
                    return {canAdd: false};
                }
                
                const wilds = combo.cards.filter(c => c.rank === '2');
                const nonWilds = combo.cards.filter(c => c.rank !== '2');
                
                // Check if it's a set (same rank)
                if (nonWilds.length > 0) {
                    const rank = nonWilds[0].rank;
                    const allSameRank = nonWilds.every(c => c.rank === rank);
                    
                    if (allSameRank) {
                        // Can add same rank or a wild 2
                        if (card.rank === rank || card.rank === '2') {
                            const points = card.rank === '2' ? nonWilds[0].getValue() : card.getValue();
                            return {canAdd: true, points: points};
                        }
                    }
                }
                
                // Check if it's a run (sequential same suit)
                if (nonWilds.length > 0) {
                    const suit = nonWilds[0].suit;
                    const allSameSuit = nonWilds.every(c => c.suit === suit);
                    
                    if (allSameSuit) {
                        const ranks = nonWilds.map(c => c.getRankValue()).sort((a,b) => a - b);
                        const minRank = ranks[0];
                        const maxRank = ranks[ranks.length - 1];
                        
                        // Can add if card extends the run or is a wild 2
                        if (card.suit === suit) {
                            const cardRank = card.getRankValue();
                            if (cardRank === minRank - 1 || cardRank === maxRank + 1) {
                                return {canAdd: true, points: card.getValue()};
                            }
                        } else if (card.rank === '2') {
                            // Wild can extend run
                            const points = nonWilds[0].getValue();
                            return {canAdd: true, points: points};
                        }
                    }
                }
                
                return {canAdd: false};
            }

            validateCombo(cards) {
                if (cards.length < 3) {
                    return {valid: false, error: 'Need 3+ cards for a combination'};
                }
                if (cards.length > 13) {
                    return {valid: false, error: 'Too many cards!'};
                }

                const sorted = [...cards].sort((a,b) => a.getRankValue() - b.getRankValue());
                const wilds = sorted.filter(c => c.rank === '2');
                const nonWilds = sorted.filter(c => c.rank !== '2');

                // All wilds
                if (wilds.length === cards.length) {
                    return {valid: true, points: wilds.length * 50, type: `${wilds.length} Wild 2s`};
                }

                // Check set (same rank)
                if (nonWilds.length > 0) {
                    const rank = nonWilds[0].rank;
                    const isSet = nonWilds.every(c => c.rank === rank);
                    
                    if (isSet && cards.length <= 4) {
                        const value = nonWilds[0].getValue();
                        const points = cards.length * value;
                        return {valid: true, points: points, type: `${cards.length}x ${rank}`};
                    } else if (isSet && cards.length > 4) {
                        return {valid: false, error: 'Maximum 4 of a kind allowed!'};
                    }
                }

                // Check run (sequential same suit)
                if (nonWilds.length > 0) {
                    const suit = nonWilds[0].suit;
                    if (!nonWilds.every(c => c.suit === suit)) {
                        return {valid: false, error: 'Run must be all the same suit!'};
                    }
                    
                    const ranks = nonWilds.map(c => c.getRankValue()).sort((a,b) => a - b);
                    
                    // Check if sequential with wilds filling gaps
                    let isSequential = true;
                    let wildsNeeded = 0;
                    
                    for (let i = 1; i < ranks.length; i++) {
                        const gap = ranks[i] - ranks[i-1] - 1;
                        if (gap > 0) {
                            wildsNeeded += gap;
                        } else if (gap < 0) {
                            return {valid: false, error: 'Run cannot have duplicate ranks!'};
                        }
                    }
                    
                    if (wildsNeeded > wilds.length) {
                        return {valid: false, error: 'Not enough wild cards to complete the run!'};
                    }
                    
                    let points = nonWilds.reduce((sum, c) => sum + c.getValue(), 0);
                    points += wilds.length * (nonWilds[0] ? nonWilds[0].getValue() : 10);
                    return {valid: true, points: points, type: `Run (${suit})`};
                }

                return {valid: false, error: 'Not a valid combination! Must be a set (same rank) or run (sequential same suit).'};
            }

            sacrificeCard() {
                if (this.phase !== 'sacrifice' && this.phase !== 'play') {
                    this.showMessage('‚ùå Wrong phase! You are in: ' + this.phase.toUpperCase(), 'error');
                    return;
                }
                
                if (this.selected.length !== 1) {
                    this.showMessage('‚ùå Select exactly 1 card to sacrifice! You have ' + this.selected.length + ' selected.', 'warning');
                    return;
                }

                const currentHand = this.turn === 0 ? this.playerHand : this.opponentHand;
                const card = currentHand[this.selected[0]];
                currentHand.splice(this.selected[0], 1);
                this.river.push(card);
                this.selected = [];

                const playerName = this.gameMode === 'local' 
                    ? `Player ${this.turn + 1}` 
                    : (this.turn === 0 ? 'You' : 'AI');
                
                this.showMessage(`‚úì ${playerName} sacrificed ${card.rank}${card.getSuit()} to the river`, 'info');

                // Handle first turn (initial sacrifices only - no draw phase)
                if (this.firstTurn) {
                    // Track how many players have sacrificed
                    if (!this.firstSacrificesDone) {
                        this.firstSacrificesDone = [];
                    }
                    
                    if (!this.firstSacrificesDone.includes(this.turn)) {
                        this.firstSacrificesDone.push(this.turn);
                    }
                    
                    // If both players have sacrificed, end first turn and start normal play
                    if (this.firstSacrificesDone.length === 2) {
                        this.firstTurn = false;
                        this.turn = this.firstGameStarter === 0 ? 1 : 0; // Non-cutter goes first
                        this.phase = 'draw';
                        const nextPlayer = this.gameMode === 'local' 
                            ? `Player ${this.turn + 1}` 
                            : (this.turn === 0 ? 'You' : 'AI');
                        this.showMessage(`Both players sacrificed (now 7 cards each). ${nextPlayer}'s turn to draw!`, 'info');
                        this.render();
                        
                        if (this.gameMode === 'local') {
                            setTimeout(() => this.showTurnScreen(), 1000);
                        } else if (this.turn === 1) {
                            setTimeout(() => this.aiTurn(), 1500);
                        }
                    } else {
                        // Switch to other player for their first sacrifice
                        this.turn = this.turn === 0 ? 1 : 0;
                        this.render();
                        
                        if (this.gameMode === 'local') {
                            setTimeout(() => this.showTurnScreen(), 1000);
                        } else if (this.turn === 1) {
                            setTimeout(() => this.aiSacrifice(), 1500);
                        }
                    }
                } else {
                    // Normal turn switch (after first turn)
                    this.turn = this.turn === 0 ? 1 : 0;
                    this.phase = 'draw';
                    this.render();
                    
                    if (this.gameMode === 'local') {
                        setTimeout(() => this.showTurnScreen(), 1000);
                    } else if (this.turn === 1) {
                        setTimeout(() => this.aiTurn(), 1500);
                    }
                }
            }

            aiSacrifice() {
                if (this.opponentHand.length === 0) return;
                
                const idx = Math.floor(Math.random() * this.opponentHand.length);
                const card = this.opponentHand.splice(idx, 1)[0];
                this.river.push(card);
                
                this.showMessage('AI sacrificed a card to the river', 'info');
                
                if (this.firstTurn) {
                    // Track AI sacrifice
                    if (!this.firstSacrificesDone) {
                        this.firstSacrificesDone = [];
                    }
                    
                    if (!this.firstSacrificesDone.includes(1)) {
                        this.firstSacrificesDone.push(1);
                    }
                    
                    // Check if both have sacrificed
                    if (this.firstSacrificesDone.length === 2) {
                        // Both sacrificed, start normal play
                        this.firstTurn = false;
                        this.turn = this.firstGameStarter === 0 ? 1 : 0;
                        this.phase = 'draw';
                        
                        if (this.turn === 0) {
                            this.showMessage('Both players sacrificed (now 7 cards each). Your turn to draw!', 'info');
                        } else {
                            this.showMessage('Both players sacrificed. AI\'s turn to draw!', 'info');
                            setTimeout(() => this.aiTurn(), 1500);
                        }
                        this.render();
                    } else {
                        // Switch to player for their sacrifice
                        this.turn = 0;
                        this.showMessage('AI sacrificed. Your turn to sacrifice!', 'info');
                        this.render();
                    }
                } else {
                    // Should not happen during normal play
                    this.turn = 0;
                    this.phase = 'draw';
                    this.showMessage('AI sacrificed. Your turn!', 'info');
                    this.render();
                }
            }

            aiTurn() {
                // Draw phase
                setTimeout(() => {
                    // AI picks from river if they've played their first combo and river has cards
                    if (this.opponentFirstPlay && this.river.length > 2 && Math.random() > 0.5) {
                        const idx = Math.floor(Math.random() * this.river.length);
                        this.pickFromRiver(idx);
                    } else if (this.deck.length > 0) {
                        this.drawFromDeck();
                    } else if (this.river.length > 0 && this.opponentFirstPlay) {
                        this.pickFromRiver(0);
                    }
                    
                    // Play phase - try to play multiple combinations if possible
                    setTimeout(() => {
                        let playedSomething = true;
                        let attempts = 0;
                        
                        // Keep trying to play combinations until none are found
                        while (playedSomething && attempts < 5) {
                            playedSomething = this.aiPlay();
                            attempts++;
                            
                            if (playedSomething && this.opponentHand.length === 0) {
                                this.endRound();
                                return;
                            }
                        }
                        
                        // Sacrifice phase
                        setTimeout(() => {
                            if (this.opponentHand.length > 0) {
                                const idx = Math.floor(Math.random() * this.opponentHand.length);
                                this.selected = [idx];
                                this.sacrificeCard();
                            }
                        }, 1200);
                    }, 1200);
                }, 1200);
            }

            aiPlay() {
                // Try to find any valid combination the AI can make
                const hand = this.opponentHand;
                
                // Check for banned card
                const isBanned = (card) => {
                    if (!this.bannedCard) return false;
                    return card.rank === this.bannedCard.rank && card.suit === this.bannedCard.suit;
                };
                
                // Try to find sets (3-4 of same rank)
                const rankGroups = {};
                hand.forEach(card => {
                    if (!isBanned(card)) {
                        if (!rankGroups[card.rank]) rankGroups[card.rank] = [];
                        rankGroups[card.rank].push(card);
                    }
                });
                
                // Look for sets of 3 or 4
                for (let rank in rankGroups) {
                    const cards = rankGroups[rank];
                    if (cards.length >= 3) {
                        // Try 4 first, then 3
                        for (let len = Math.min(4, cards.length); len >= 3; len--) {
                            const combo = cards.slice(0, len);
                            const result = this.validateCombo(combo);
                            
                            if (result.valid && (!this.opponentFirstPlay ? result.points >= 25 : true)) {
                                this.selected = [];
                                combo.forEach(card => {
                                    const idx = hand.indexOf(card);
                                    if (idx > -1) this.selected.push(idx);
                                });
                                this.playCombination();
                                return true;
                            }
                        }
                    }
                }
                
                // Try to find runs (sequential same suit)
                const suitGroups = {};
                hand.forEach(card => {
                    if (!isBanned(card) && card.rank !== '2') {
                        if (!suitGroups[card.suit]) suitGroups[card.suit] = [];
                        suitGroups[card.suit].push(card);
                    }
                });
                
                // Get wild 2s
                const wilds = hand.filter(c => c.rank === '2' && !isBanned(c));
                
                // Look for runs in each suit
                for (let suit in suitGroups) {
                    const cards = suitGroups[suit].sort((a, b) => a.getRankValue() - b.getRankValue());
                    
                    // Try to find sequential runs of length 3+
                    for (let start = 0; start < cards.length; start++) {
                        for (let end = start + 2; end <= cards.length; end++) {
                            const runCards = cards.slice(start, end);
                            const ranks = runCards.map(c => c.getRankValue());
                            
                            // Check if sequential or can be made sequential with wilds
                            let gapsNeeded = 0;
                            for (let i = 1; i < ranks.length; i++) {
                                gapsNeeded += (ranks[i] - ranks[i-1] - 1);
                            }
                            
                            if (gapsNeeded <= wilds.length) {
                                // Can make a run
                                const combo = [...runCards, ...wilds.slice(0, gapsNeeded)];
                                const result = this.validateCombo(combo);
                                
                                if (result.valid && (!this.opponentFirstPlay ? result.points >= 25 : true)) {
                                    this.selected = [];
                                    combo.forEach(card => {
                                        const idx = hand.indexOf(card);
                                        if (idx > -1) this.selected.push(idx);
                                    });
                                    this.playCombination();
                                    return true;
                                }
                            }
                        }
                    }
                }
                
                // Try to use wild 2s in sets
                if (wilds.length >= 3) {
                    const result = this.validateCombo(wilds);
                    if (result.valid && (!this.opponentFirstPlay ? result.points >= 25 : true)) {
                        this.selected = [];
                        wilds.forEach(card => {
                            const idx = hand.indexOf(card);
                            if (idx > -1) this.selected.push(idx);
                        });
                        this.playCombination();
                        return true;
                    }
                }
                
                // Try combinations with wild 2s added to sets
                if (wilds.length > 0) {
                    for (let rank in rankGroups) {
                        const cards = rankGroups[rank];
                        if (cards.length >= 2 && cards.length + wilds.length >= 3) {
                            const combo = [...cards.slice(0, Math.min(3, cards.length)), ...wilds.slice(0, Math.max(0, 3 - cards.length))];
                            const result = this.validateCombo(combo);
                            
                            if (result.valid && (!this.opponentFirstPlay ? result.points >= 25 : true)) {
                                this.selected = [];
                                combo.forEach(card => {
                                    const idx = hand.indexOf(card);
                                    if (idx > -1) this.selected.push(idx);
                                });
                                this.playCombination();
                                return true;
                            }
                        }
                    }
                }
                
                return false;
            }

            endRound() {
                let playerLeft = this.playerHand.reduce((sum, c) => sum + c.getValue(), 0);
                let opponentLeft = this.opponentHand.reduce((sum, c) => sum + c.getValue(), 0);

                const p1Name = this.gameMode === 'local' ? 'Player 1' : 'You';
                const p2Name = this.gameMode === 'local' ? 'Player 2' : 'AI';

                if (this.playerHand.length === 0) {
                    this.opponentRound -= opponentLeft;
                    this.showMessage(`Round over! ${p1Name} emptied their hand. ${p2Name} loses ${opponentLeft} points.`, 'success');
                } else {
                    this.playerRound -= playerLeft;
                    this.showMessage(`Round over! ${p2Name} emptied their hand. ${p1Name} loses ${playerLeft} points.`, 'warning');
                }

                this.playerTotal += this.playerRound;
                this.opponentTotal += this.opponentRound;
                this.render();

                setTimeout(() => {
                    if (this.playerTotal >= 500) {
                        this.showMessage(`üéâ ${p1Name} WINS! Final: ${this.playerTotal} to ${this.opponentTotal} üéâ`, 'success');
                    } else if (this.opponentTotal >= 500) {
                        this.showMessage(`${p2Name} wins! Final: ${this.opponentTotal} to ${this.playerTotal}`, 'warning');
                    } else {
                        // Alternate who starts next round
                        this.firstGameStarter = this.firstGameStarter === 0 ? 1 : 0;
                        this.showMessage('New round starting...', 'info');
                        setTimeout(() => {
                            document.getElementById('gameContainer').style.display = 'none';
                            this.showCuttingScreen();
                        }, 2000);
                    }
                }, 2500);
            }

            clearSelection() {
                this.selected = [];
                this.render();
            }

            showMessage(text, type) {
                const box = document.getElementById('messageBox');
                box.textContent = text;
                box.className = `message msg-${type}`;
                box.style.display = 'block';
            }

            toggleRules() {
                const rules = document.getElementById('rulesSection');
                rules.style.display = rules.style.display === 'none' ? 'block' : 'none';
            }

            render() {
                // Scores
                document.getElementById('playerTotal').textContent = this.playerTotal;
                document.getElementById('opponentTotal').textContent = this.opponentTotal;
                document.getElementById('playerRound').textContent = this.playerRound;
                document.getElementById('opponentRound').textContent = this.opponentRound;
                document.getElementById('deckCount').textContent = this.deck.length;

                // Turn indicators
                document.getElementById('playerTurnIndicator').style.display = this.turn === 0 ? 'inline-block' : 'none';
                document.getElementById('oppTurnIndicator').style.display = this.turn === 1 ? 'inline-block' : 'none';

                // Update hand title
                if (this.gameMode === 'local') {
                    document.getElementById('currentHandTitle').textContent = `PLAYER ${this.turn + 1}`;
                } else {
                    document.getElementById('currentHandTitle').textContent = 'YOUR';
                }

                // Show hand based on mode
                const handDiv = document.getElementById('playerHand');
                handDiv.innerHTML = '';
                
                if (this.gameMode === 'local') {
                    // Local mode: show current player's hand
                    const currentHand = this.turn === 0 ? this.playerHand : this.opponentHand;
                    currentHand.forEach((card, i) => {
                        const div = document.createElement('div');
                        div.innerHTML = card.toHTML();
                        const cardEl = div.firstElementChild;
                        if (this.selected.includes(i)) cardEl.classList.add('selected');
                        cardEl.onclick = () => this.selectCard(i);
                        handDiv.appendChild(cardEl);
                    });
                } else {
                    // AI mode: ONLY show player's hand, never AI's hand
                    this.playerHand.forEach((card, i) => {
                        const div = document.createElement('div');
                        div.innerHTML = card.toHTML();
                        const cardEl = div.firstElementChild;
                        if (this.selected.includes(i)) cardEl.classList.add('selected');
                        cardEl.onclick = () => this.selectCard(i);
                        handDiv.appendChild(cardEl);
                    });
                }

                // River
                const riverDiv = document.getElementById('riverZone');
                if (this.river.length === 0) {
                    riverDiv.innerHTML = '<div class="empty-text">River is empty</div>';
                } else {
                    riverDiv.innerHTML = '';
                    this.river.forEach((card, i) => {
                        const wrapper = document.createElement('div');
                        wrapper.className = 'river-card';
                        wrapper.innerHTML = `
                            <div class="river-number">${i + 1}</div>
                            ${card.toHTML()}
                        `;
                        wrapper.firstElementChild.nextElementSibling.onclick = () => this.selectRiver(i);
                        riverDiv.appendChild(wrapper);
                    });
                }

                // Combinations
                this.renderCombos('playerCombos', this.playerCombos);
                this.renderCombos('opponentCombos', this.opponentCombos);
            }

            renderCombos(id, combos) {
                const div = document.getElementById(id);
                if (combos.length === 0) {
                    div.innerHTML = '<div class="empty-text">No combinations yet</div>';
                } else {
                    div.innerHTML = '';
                    combos.forEach((combo, idx) => {
                        const wrapper = document.createElement('div');
                        wrapper.className = 'combination';
                        let html = '';
                        combo.cards.forEach(c => html += c.toHTML());
                        html += `<span class="combo-points">+${combo.points}</span>`;
                        wrapper.innerHTML = html;
                        
                        // Add visual indicator that combos can be added to
                        wrapper.style.cursor = 'pointer';
                        wrapper.title = 'Click a single card in your hand to add it here';
                        
                        div.appendChild(wrapper);
                    });
                }
            }
        }

        const game = new Game();
    </script>
</body>
</html>
